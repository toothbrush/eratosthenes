\documentclass[a4paper]{article}

\usepackage{lgrind}
\usepackage{graphicx}
\usepackage{hyperref}

\author{Paul van der Walt\\\url{paul@denknerd.org}}
\date{\today}
\title{Parallel Algorithms: Eratosthenes' Sieve}

\begin{document}
\maketitle
\begin{abstract}
    In this report the findings are presented after benchmarking the Dutch
    supercomputer Huygens and a personal computer. The Sieve of Eratosthenes is
    then implemented in sequence and parallel (including a number of performance
    improvements), and tested on Huygens and a
    personal computer. 
\end{abstract}
\tableofcontents

\section{Introduction}

This report documents the use of BSP-style\cite{BSP} parallel programming to
find primes in parallel, using Eratosthenes' method. 

The so-called sieve of Eratosthenes is an old and unsophisticated method for
finding all primes up to a given number $N$, which lends itself quite nicely to
parallelisation. The idea is roughly as follows: start with the lowest known
prime $i$ (given: $i \leftarrow 2$ in the first iteration) and cross all
multiples of $i$ out of your list of potential primes, which starts off with all
natural numbers 1\ldots$N$. While $i$ is less than $N$, repeat. The next lowest
known prime is the smallest number which hasn't been crossed off the list yet.
More information about Eratosthenes' prime sieve can be found in Section
\ref{sec:sieve}. 

Secondly, we take a look at benchmarking BSP computers and the performance
measured when testing on Huygens\cite{sarahuygens}, the Dutch national
supercomputer, and on a recent MacBook. Specifically, the benchmark is aimed at
parallel computers, measuring not only computation speed, but also
synchronisation time and communication speed. 



\section{Prime Sieve}\label{sec:sieve}


\section{Benchmarks}

The two computers tested in this section, as already mentioned, are a recent
MacBook\footnote{Core2Duo 2.4Ghz with 4GB memory.} and Huygens, the national
supercomputer. Of course we didn't do the benchmark on all the nodes of Huygens,
as there are in the order of three thousand of them, but only on 2 and 32 nodes. 

The benchmark that has been done is the one included in BSPedupack which can be
found at \cite{edupack}, referred to as \texttt{bspbench.c}. The results are
presented in Figures 1..2. 
\subsection{Original benchmark}
\begin{figure}[h]
    \begin{center}
        \includegraphics{img/bench-huy-put-p2.png}
    \end{center}
    \caption{Benchmark results on Huygens with $P$=2; the benchmark bottom line
    was $r=$ 194.357 Mflop/s, $g=$ 54.2, $l=$ 1986.4}
    \label{fig:bench-huy-put-p2}
\end{figure}

\begin{figure}[h]
    \begin{center}
        \includegraphics{img/bench-laptop-put.png}
    \end{center}
    \caption{Benchmark results on MacBook with $P$=2; bottom line was  $r=$
    399.853 Mflop/s, $g=$ 30.9, $l=$ 1112.4 }
    \label{fig:bench-laptop-put-p2}
\end{figure}

Story about distributed $P=2$ on Huygens. Talk about above 2 figs. 

\begin{figure}[h]
    \begin{center}
        \includegraphics{img/bench-huy-put-p2-dist}
    \end{center}
    \caption{The same test as in Figure \ref{fig:bench-huy-put-p2}, but then
    instead of 2 processes on one node, we tried 2 processes on 2 nodes. The
    bottom line becomes $r=$ 195.648 Mflop/s, $g=$ 100.2, $l=$ 15770.4}
    \label{fig:bench-huy-put-p2-dist}
\end{figure}

Note the increased communication time??

\subsection{Changing to \texttt{get}s}
Now we change puts into gets\ldots

\begin{figure}[h]
    \begin{center}
        \includegraphics{img/bench-huy-get-p2.png}
    \end{center}
    \caption{Having changed \texttt{put}s into \texttt{get}s we measure again on
    Huygens with $P=2$. Bottom line: $r=$ 191.062 Mflop/s, $g=$ 87.2, $l=$ 2574.6}
    \label{fig:bench-huy-get-p2}
\end{figure}

\begin{figure}[h]
    \begin{center}
        \includegraphics{img/bench-laptop-get.png}
    \end{center}
    \caption{MacBook with $P=2$. Bottom line: $r=$ 389.348 Mflop/s, $g=$ 43.5, $l=$ 1240.1}
    \label{fig:bench-laptop-get-p2}
\end{figure}

\begin{figure}[h]
    \begin{center}
        \includegraphics{img/bench-huy-get-p2-dist}
    \end{center}
    \caption{The same test as in Figure \ref{fig:bench-huy-get-p2}, but then
    instead of 2 processes on one node, we tried 2 processes on 2 nodes. The
    bottom line becomes $r=$ 194.498 Mflop/s, $g=$ 182.3, $l=$ 24222.0}
    \label{fig:bench-huy-get-p2-dist}
\end{figure}

Now we try 56 procs on the MacBook

\begin{figure}[h]
    \begin{center}
        \includegraphics{img/bench-laptop-get-p56.png}
    \end{center}
    \caption{Test on the MacBook with $P=56$, using \texttt{get}s. Bottom line
    now becomes $r=$ 445.799 Mflop/s, $g=$ 4201.9, $l=$ 10037639.0}
    \label{fig:bench-laptop-get-p56}
\end{figure}



\appendix
\section{Sequential sieve code}

\lgrindfile{../seq/sieve.lg}

\section{Parallel sieve code}

\lgrindfile{../par/bspsieve.lg}


\begin{thebibliography}{99}
    \bibitem[BSP]{BSP} \url{http://www.bsp-worldwide.org}, homepage of the BSP
        association. 
    \bibitem[SHuy]{sarahuygens}
        \url{https://subtrac.sara.nl/userdoc/wiki/huygens/description},
        information page on the Huygens supercomputer. 
    \bibitem[BSPep]{edupack}
        \url{http://www.staff.science.uu.nl/~bisse101/Software/software.html}, homepage of BSPedupack, an education set of sample code for the
        BSP library. 
\end{thebibliography}

\end{document}
